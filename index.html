<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Essensrückmeldung</title>
    <style>
        /* --- START OF style.css content --- */

        /* Basic Reset & Defaults */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            overflow: hidden; /* Prevent scrollbars if possible */
        }

        #app-container {
            background-color: #fff;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            width: 90vw; /* Use viewport width */
            max-width: 1000px; /* Adjust max width */
            height: 80vh; /* Use viewport height */
            max-height: 600px; /* Adjust max height */
            display: flex;
            overflow: hidden; /* Contain content */
            position: relative; /* Needed for z-index stacking and corner buttons */
        }

        /* Screen Management */
        .screen {
            display: none; /* Hidden by default */
            position: absolute; /* Position within #app-container */
            top: 0; left: 0; width: 100%; height: 100%;
            flex-direction: column;
            align-items: center;
            opacity: 1; /* Ensure visible by default */
            z-index: 1; /* Default stack level */
            background-color: #fff; /* Ensure background isn't transparent */
        }
        .screen.active {
            display: flex; /* Show active screen */
            z-index: 2; /* Bring active screen to front */
        }

        /* Main Feedback Screen Layout */
        /* --- CHANGE: Add controls-disabled class --- */
        #feedback-section {
            flex-direction: row;
            align-items: stretch;
        }

        /* --- Sidebar (Left) --- */
        .feedback-sidebar {
            flex: 0 0 20%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px 10px;
            gap: 20px;
            border-right: 1px solid #e0e0e0;
            overflow-y: auto; /* Allow sidebar scroll if needed */
        }
        .feedback-sidebar .group-button {
            background-color: transparent; border: none; cursor: pointer; padding: 0;
            text-align: center; border-radius: 20px; width: 90%; max-width: 150px;
            transition: transform 0.2s ease, opacity 0.35s ease, filter 0.35s ease, box-shadow 0.2s ease, background-color 0.2s ease;
            overflow: hidden; flex-shrink: 0; /* Prevent shrinking */
        }
        .feedback-sidebar .group-button img {
            display: block; width: 100%; height: auto; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        /* --- Main Content Area (Right) --- */
        .feedback-main-content {
            flex: 1; /* Take remaining space */
            display: flex;
            flex-direction: column; /* Stack items vertically */
            justify-content: flex-end; /* Push content towards the bottom */
            align-items: center; /* Center items horizontally */
            padding: 20px 30px 0; /* Add padding, remove bottom padding (handled by vh) */
            padding-bottom: 15vh; /* Space below the lowest element (rating buttons) ~30% from bottom edge */
            position: relative; /* Keep for corner buttons */
            overflow-y: auto; /* Allow scrolling if content overflows */
            height: 100%; /* Ensure it tries to take full height */
        }

        /* --- Wrapper for Heading + Comment Group (Now direct child of main-content) --- */
        .main-center-wrapper {
            display: flex;
            flex-direction: column;
            align-items: flex-start; /* Keep content left-aligned */
            width: 100%; /* Take full width of parent */
            max-width: 530px; /* Apply max-width */
            gap: 15px; /* Space between heading and comment group */
            margin-bottom: 5vh; /* Reduced space above rating buttons */
            flex-shrink: 0; /* Prevent shrinking */
            transition: opacity 0.3s ease, filter 0.3s ease; /* Add transition */
        }

        /* --- Heading (inside main-center-wrapper) --- */
        .main-center-wrapper h2 {
            color: #333;
            font-size: 1.6em;
            text-align: left; /* Keep text left-aligned */
            width: 100%;
            margin-bottom: 0; /* Use gap in parent */
            transition: color 0.3s ease; /* Add transition for color */
        }

        /* --- Comment Group (inside main-center-wrapper) --- */
        .comment-group {
             width: 100%; /* Take full width of parent wrapper */
             display: flex;
             flex-direction: column; /* Stack elements vertically */
             align-items: center; /* Center children (textarea row, clear button, error) */
             gap: 5px; /* Space between textarea row, clear button, error */
             flex-shrink: 0; /* Prevent shrinking */
             margin-top: 0; /* Use gap in parent */
             transition: opacity 0.3s ease, filter 0.3s ease; /* Add transition */
         }
        .comment-input-row {
            width: 100%; display: flex; align-items: flex-start; gap: 8px;
        }
        #comment {
            flex-grow: 1; padding: 10px; border: 1px solid #ccc; border-radius: 5px;
            font-size: 1em; min-height: 60px; height: 60px; resize: vertical; font-family: inherit;
            background-color: #f8f9fa; /* Lighter background */
            cursor: pointer; /* Indicate clickable for mic */
            overflow-y: auto; /* Ensure scrollbar appears if needed */
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        #record-comment-button {
            flex-shrink: 0; width: 40px; height: 40px; margin-top: 5px; border-radius: 50%;
            border: 1px solid #ccc; background-color: #f0f2f5; color: #555; cursor: pointer;
            display: flex; justify-content: center; align-items: center; font-size: 1.4em;
            transition: background-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease, opacity 0.3s ease, border-color 0.3s ease;
        }
        #record-comment-button:hover:not(:disabled) { background-color: #e4e6e9; } /* Only hover when enabled */
        #record-comment-button:disabled { cursor: not-allowed; /* Opacity handled by parent .controls-disabled */ }
        #record-comment-button.is-recording { background-color: #ffdddd; border-color: #dc3545; box-shadow: 0 0 8px rgba(220, 53, 69, 0.5); animation: simple-pulse 1s infinite alternate; }
        @keyframes simple-pulse { from { transform: scale(1); } to { transform: scale(1.05); } }
        #record-comment-button .mic-icon.default { display: inline; }
        #record-comment-button .mic-icon.recording { display: none; color: #dc3545; }
        #record-comment-button.is-recording .mic-icon.default { display: none; }
        #record-comment-button.is-recording .mic-icon.recording { display: inline; }
        #record-comment-button.is-transcribing { background-color: #ddeeff; box-shadow: 0 0 8px rgba(100, 150, 255, 0.5); cursor: not-allowed; animation: none; }

        .clear-button {
          display: block; /* Toggled by JS */
          width: 100%;
          padding: 8px 15px;
          background-color: #e0e0e0; /* Grey for Löschen */
          color: #333;
          border: 1px solid #ccc;
          border-radius: 5px;
          cursor: pointer;
          font-size: 0.9em;
          text-align: center;
          transition: background-color 0.2s ease, color 0.2s ease, opacity 0.3s ease, border-color 0.3s ease;
          margin-top: 5px;
        }
        .clear-button:hover:not(:disabled) {
            background-color: #d1d1d1; /* Hover for Löschen */
        }
        .clear-button:disabled {
             cursor: not-allowed;
             /* Visual grey-out handled by parent .controls-disabled or direct JS opacity if needed */
             background-color: #f0f0f0; /* Ensure a light grey background when disabled */
             color: #aaa;
             border-color: #e0e0e0;
        }
        .error-message {
            width: 100%; color: #dc3545; font-size: 0.9em; margin-top: 0;
            min-height: 1.2em; text-align: center; padding-left: 0; display: block;
        }

        /* --- Rating Circles Container (Now direct child of main-content) --- */
        .feedback-options {
            display: flex;
            justify-content: center; /* Keep buttons centered horizontally */
            align-items: center;
            flex-direction: row; /* Arrange buttons in a row */
            gap: 35px; /* Keep gap between buttons */
            width: 100%; /* Allow it to take width */
            max-width: 600px; /* Apply max-width */
            flex-wrap: wrap; /* Allow wrapping if space is extremely tight */
            margin-top: 0; /* Remove margin */
            padding-bottom: 0; /* Remove padding */
            flex-shrink: 0; /* Prevent shrinking */
            transition: opacity 0.3s ease, filter 0.3s ease; /* Add transition */
        }
        .feedback-button {
            border: none; border-radius: 50%; width: 160px; height: 160px; cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.3s ease, background-color 0.3s ease; /* Added background-color transition */
            display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center;
            padding: 15px; box-shadow: 0 5px 12px rgba(0,0,0,0.2); color: white; font-weight: bold;
            font-size: 1.1em; line-height: 1.3;
            flex-shrink: 0;
        }
        .feedback-button span { display: block; }
        .feedback-button:hover:not(:disabled) { transform: scale(1.06); box-shadow: 0 8px 20px rgba(0,0,0,0.25); }
        .feedback-button.positive { background-color: #28a745; }
        .feedback-button.neutral { background-color: #ffc107; color: white; } /* Ensure text color is white */
        .feedback-button.negative { background-color: #dc3545; }
        .feedback-button:disabled {
            opacity: 0.6; /* Slightly more visible than pure grey-out if needed */
            cursor: not-allowed;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transform: scale(0.98);
            pointer-events: none; /* Double ensure no interaction */
            /* Grey-out color handled by parent .controls-disabled */
        }

        /* --- Container for Top-Right Buttons --- */
        #top-right-buttons {
            position: absolute; top: 15px; right: 20px; display: flex; flex-direction: column;
            gap: 8px; align-items: flex-end; z-index: 3; /* Needs high z-index */
        }
        .corner-group-button {
            background-color: #6c757d; color: white; border: none; border-radius: 12px; padding: 8px 15px;
            font-size: 0.9em; cursor: pointer; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
            transition: transform 0.2s ease, opacity 0.35s ease, filter 0.35s ease, background-color 0.2s ease, box-shadow 0.2s ease;
            width: 100px; text-align: center;
        }

        /* --- Loading Indicator (Now direct child of main-content) --- */
        #loading-indicator {
            font-size: 1.1em; color: #555;
            margin-top: 15px; /* Add some space if it appears */
            flex-shrink: 0;
        }

        /* --- Selection State Styling --- */
        #feedback-section.group-selected .group-button:not(.selected) { opacity: 0.35; filter: grayscale(90%); }
        #feedback-section .group-button.selected { opacity: 1; filter: grayscale(0%); transform: scale(1.03); }
        #feedback-section .corner-group-button.selected { background-color: #495057; box-shadow: 0 0 10px rgba(73, 80, 87, 0.7); }
        #feedback-section .feedback-sidebar .group-button.selected { box-shadow: 0 0 14px rgba(0, 100, 255, 0.7); }

        /* --- Hover effects --- */
        .feedback-sidebar .group-button:not(.selected):hover { transform: scale(1.05); background-color: rgba(0, 0, 0, 0.03); }
        .corner-group-button:not(.selected):hover { background-color: #5a6268; transform: scale(1.05); }

        /* --- Screen 3: Thank You --- */
        #thank-you { background-color: #fff; justify-content: center; } /* Ensure centering */
        #thank-you-text { font-size: 5em; color: #28a745; font-weight: bold; text-align: center; animation: quickPop 0.4s ease-out; }
        @keyframes quickPop { 0% { transform: scale(0.7); opacity: 0.5; } 70% { transform: scale(1.05); opacity: 1; } 100% { transform: scale(1); opacity: 1; } }

        /* --- Utility class to hide elements --- */
        .hidden { display: none !important; }

        /* --- CHANGE: Styles for disabled controls state --- */
        #feedback-section.controls-disabled .main-center-wrapper,
        #feedback-section.controls-disabled .feedback-options {
            opacity: 0.4; /* Make elements semi-transparent */
            filter: grayscale(90%); /* Remove color */
            pointer-events: none; /* Prevent interaction with children */
        }

        #feedback-section.controls-disabled .main-center-wrapper h2 {
            color: #aaa; /* Lighter text color for heading */
        }

        /* Ensure buttons *within* the disabled containers visually reflect disable state */
        #feedback-section.controls-disabled .feedback-button,
        #feedback-section.controls-disabled #record-comment-button,
        #feedback-section.controls-disabled .clear-button {
            box-shadow: none; /* Remove shadow for flatter look */
             /* Backgrounds should ideally inherit greyness but set explicitly if needed */
            background-color: #e9ecef; /* Light grey background */
            color: #adb5bd; /* Muted text color */
            border-color: #ced4da; /* Muted border color */
            cursor: not-allowed; /* Explicitly set cursor */
        }
         /* Override specific button colors when disabled */
        #feedback-section.controls-disabled .feedback-button.positive,
        #feedback-section.controls-disabled .feedback-button.neutral,
        #feedback-section.controls-disabled .feedback-button.negative {
             background-color: #e9ecef;
             color: #adb5bd;
        }
        #feedback-section.controls-disabled #comment {
            background-color: #e9ecef; /* Match other disabled elements */
            border-color: #ced4da;
            cursor: not-allowed;
        }

        /* --- Responsive Adjustments --- */
        @media (max-width: 768px) {
            #app-container { width: 95vw; height: 90vh; max-height: none; flex-direction: column; }
            #feedback-section { flex-direction: column; }

            .feedback-sidebar {
                order: 5; /* Sidebar last */
                width: 100%; flex-direction: row; justify-content: center; flex-wrap: wrap;
                padding: 15px 10px; border-right: none; border-top: 1px solid #e0e0e0; gap: 10px; overflow-y: visible;
                 flex-shrink: 0;
            }
            .feedback-sidebar .group-button { width: auto; max-width: 80px; }

            .feedback-main-content {
                order: 1; /* Main content area first */
                flex: 1;
                padding: 15px; /* Restore padding */
                justify-content: flex-start; /* Align top */
                gap: 15px; /* Use gap for vertical spacing */
                overflow-y: auto;
                position: static;
                width: 100%;
                padding-bottom: 20px; /* Standard padding */
            }

            #top-right-buttons {
                order: 1; /* Top buttons first within main content */
                position: static;
                flex-direction: row; justify-content: flex-end;
                width: 100%; margin-bottom: 0; /* Use parent gap */
                gap: 10px; padding: 0 10px;
            }
            .corner-group-button { width: auto; padding: 6px 12px; font-size: 0.8em; border-radius: 10px; }

            .main-center-wrapper {
                order: 2; /* Heading/Comment wrapper follows top buttons */
                margin-bottom: 0; /* Use parent gap */
                max-width: 100%;
                gap: 10px;
                align-items: flex-start;
            }

            .main-center-wrapper h2 { font-size: 1.3em; text-align: left; }
            .comment-group { max-width: 100%; margin-top: 0; gap: 5px;}
            .comment-input-row { gap: 5px; }
            #comment { height: 50px; min-height: 50px; }
            #record-comment-button { width: 35px; height: 35px; font-size: 1.2em; margin-top: 3px; }
            .clear-button { font-size: 0.85em; padding: 6px 12px; }

            .feedback-options {
                order: 3; /* Rating buttons follow comment */
                gap: 15px;
                margin-top: 0; /* Use parent gap */
                padding-bottom: 0;
                width: 100%;
                max-width: 100%;
                justify-content: center;
            }
            .feedback-button { width: 100px; height: 100px; font-size: 0.9em; }

            #thank-you-text { font-size: 4em; }

            #loading-indicator {
                order: 4; /* Loading indicator follows rating buttons */
                position: static;
                margin-top: 0; /* Use parent gap */
            }
            .error-message { max-width: 100%; padding-left: 0; text-align: center;}

             /* Adjust disabled state opacity for smaller screens if needed */
             /* #feedback-section.controls-disabled .main-center-wrapper,
             #feedback-section.controls-disabled .feedback-options { opacity: 0.5; } */
        }

        @media (max-width: 480px) {
            .feedback-button { width: 80px; height: 80px; font-size: 0.8em; }
            .feedback-sidebar .group-button { max-width: 60px; }
            .corner-group-button { padding: 5px 10px; font-size: 0.75em; }
            .feedback-main-content { gap: 10px; }
            .main-center-wrapper h2 { font-size: 1.2em; }
            #comment { height: 45px; min-height: 45px; }
            #record-comment-button { width: 32px; height: 32px; font-size: 1.1em; margin-top: 2px; }
            #thank-you-text { font-size: 3em; }
            .clear-button { font-size: 0.8em; padding: 5px 10px; }
            .feedback-options { gap: 10px; margin-top: 0;}
        }

        /* --- END OF style.css content --- */
    </style>
</head>
<body>
    <div id="app-container">
        <!-- Main Feedback Screen -->
        <!-- --- CHANGE: Add controls-disabled class initially --- -->
        <div id="feedback-section" class="screen active controls-disabled">
            <!-- Sidebar -->
            <div class="feedback-sidebar">
                <button class="group-button" data-group="9-12 Klasse"><img src="9-12_klasse.png" alt="9-12 Klasse"></button>
                <button class="group-button" data-group="5-8 Klasse"><img src="5-8_klasse.png" alt="5-8 Klasse"></button>
                <button class="group-button" data-group="1-4 Klasse"><img src="1-4_klasse.png" alt="1-4 Klasse"></button>
            </div>
            <!-- Main Content -->
            <div class="feedback-main-content">
                <!-- Top Right Buttons -->
                <div id="top-right-buttons">
                    <button class="group-button corner-group-button" data-group="Lehrer">Lehrer</button>
                    <button class="group-button corner-group-button" data-group="Besucher">Besucher</button>
                </div>

                <!-- Wrapper for Heading + Comment Group -->
                <div class="main-center-wrapper">
                    <h2>Meine Rückmeldung zum Essen heute:</h2>
                    <!-- Comment Group (Textarea row, Clear Button, Error) -->
                    <div class="comment-group">
                        <div class="comment-input-row">
                            <!-- --- CHANGE: Placeholder text and readonly attribute --- -->
                            <textarea id="comment" rows="3" placeholder="Kommentar sprechen..." readonly></textarea>
                            <!-- --- CHANGE: Add disabled attribute initially --- -->
                            <button id="record-comment-button" title="Gruppe auswählen zum Diktieren" disabled>
                                <span class="mic-icon default">🎤</span>
                                <span class="mic-icon recording" style="display: none;">🟥</span>
                            </button>
                        </div>
                        <!-- --- CHANGE: Add disabled attribute initially --- -->
                        <button type="button" id="clear-comment-button" class="clear-button hidden" disabled>
                            Kommentar löschen
                        </button>
                        <p id="comment-error" class="error-message"></p>
                    </div> <!-- End of comment-group -->
                </div> <!-- End of main-center-wrapper -->

                <!-- Rating Buttons -->
                <div class="feedback-options">
                    <!-- --- CHANGE: Add disabled attribute initially --- -->
                    <button class="feedback-button positive" data-rating="1" disabled><span>mir hat es<br>geschmeckt</span></button>
                    <button class="feedback-button neutral" data-rating="2" disabled><span>war ok</span></button>
                    <button class="feedback-button negative" data-rating="3" disabled><span>hat nicht<br>geschmeckt</span></button>
                </div>

                <!-- Loading Indicator -->
                <div id="loading-indicator" style="display: none;">Sende...</div>

            </div> <!-- End of feedback-main-content -->
        </div> <!-- End of feedback-section -->

        <!-- Thank You Screen -->
        <div id="thank-you" class="screen">
             <h2 id="thank-you-text">DANKE!</h2>
        </div>
    </div>

    <script>
        // --- START OF updated script.js content ---
        console.log("--- script.js started loading ---");

        try {
            document.addEventListener('DOMContentLoaded', () => {
                console.log("--- DOMContentLoaded event fired ---");

                try {
                    // --- CONFIGURATION ---
                    const googleAppsScriptUrl = 'https://script.google.com/macros/s/AKfycbw_PX8InYEZm1tc6uVLYYZpBSTYjVB4fXXHCj62nLsZr7n6N2nspr3wXLjoP68GgIdIsw/exec';
                    const thankYouDuration = 1200;
                    const commentRequiredLength = 15;
                    const maxCommentLength = 100;
                    const CLEAR_BUTTON_TEXT_DELETE = "Kommentar löschen";
                    // ---------------------

                    // --- AUDIO CONFIGURATION ---
                    const sounds = {
                        '1-4 Klasse': new Audio('1-4_klasse.wav'), '5-8 Klasse': new Audio('5-8_klasse.mp3'),
                        '9-12 Klasse': new Audio('9-12_klasse.wav'), 'rating-1': new Audio('green.mp3'),
                        'rating-2': new Audio('yellow.mp3'), 'rating-3-success': new Audio('red.mp3'),
                        'sent': new Audio('sent.wav'), 'error': new Audio('error.wav')
                     };
                    Object.entries(sounds).forEach(([key, audio]) => { audio.onerror = (e) => console.error(`Audio Load Error '${key}':`, e); });
                    // ---------------------

                    console.log("Config & Sounds Initialized.");

                    // --- ELEMENT SELECTION ---
                    console.log("Selecting DOM elements...");
                    const feedbackScreen = document.getElementById('feedback-section');
                    const thankYouScreen = document.getElementById('thank-you');
                    const allGroupButtons = document.querySelectorAll('#feedback-section .group-button');
                    const feedbackRatingButtons = document.querySelectorAll('#feedback-section .feedback-options .feedback-button');
                    const loadingIndicator = document.getElementById('loading-indicator');
                    const commentInput = document.getElementById('comment');
                    const commentError = document.getElementById('comment-error');
                    const recordButton = document.getElementById('record-comment-button');
                    const clearCommentButton = document.getElementById('clear-comment-button');

                    // --- Initial Checks & State ---
                    if (!feedbackScreen || !thankYouScreen || !loadingIndicator || !commentInput || !commentError || !recordButton || !clearCommentButton) { console.error("CRITICAL STOP: Essential UI element missing!"); return; }
                    if (allGroupButtons.length === 0) { console.error("CRITICAL STOP: 0 group buttons found!"); return; }
                    if (feedbackRatingButtons.length === 0) { console.error("CRITICAL STOP: 0 rating buttons found!"); return; }
                    console.log("Essential elements selection successful.");

                    // feedbackRatingButtons.forEach(btn => btn.disabled = true); // Already done in HTML

                    let selectedGroup = null, selectedRating = null, isSubmitting = false, lastPlayedRatingSound = null;
                    let isMicRecording = false, isTranscribing = false;
                    let recognition;
                    let speechApiSupported = false;

                    // --- Web Speech API Setup ---
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    if (SpeechRecognition) {
                        speechApiSupported = true;
                        recognition = new SpeechRecognition();
                        recognition.continuous = false; // Stop after first pause
                        recognition.interimResults = false;
                        recognition.lang = 'de-DE';

                        recognition.onstart = () => {
                            console.log("Speech recognition started.");
                            isMicRecording = true; isTranscribing = false;
                            if (recordButton) {
                                recordButton.classList.add('is-recording'); recordButton.classList.remove('is-transcribing');
                                // Button remains clickable to stop, but title indicates state
                                recordButton.title = "Aufnahme läuft... (Zum Stoppen klicken)";
                                const defaultIcon = recordButton.querySelector('.mic-icon.default'); const recordingIcon = recordButton.querySelector('.mic-icon.recording');
                                if (defaultIcon) defaultIcon.style.display = 'none'; if (recordingIcon) recordingIcon.style.display = 'inline';
                            }
                            if(commentError) commentError.textContent = 'Höre zu...';
                            // Keep group buttons enabled, disable rating/clear during recording
                            if (feedbackRatingButtons) feedbackRatingButtons.forEach(btn => btn.disabled = true);
                            // if (allGroupButtons) allGroupButtons.forEach(btn => btn.disabled = true); // Keep groups active
                            if (clearCommentButton) clearCommentButton.disabled = true;
                            // Comment input click is handled by toggleRecording, no need to disable here explicitly
                        };

                        recognition.onresult = (event) => {
                           console.log("--- onresult event ---");
                           isTranscribing = true; // Indicate transcribing
                           if (recordButton) {
                                recordButton.classList.remove('is-recording');
                                recordButton.classList.add('is-transcribing');
                                recordButton.title = "Verarbeite...";
                                recordButton.disabled = true; // Disable click during transcription phase
                           }
                           if (commentError && commentError.textContent === 'Höre zu...') { commentError.textContent = 'Verarbeite...'; }
                           if (event.results.length > 0) {
                               const result = event.results[event.results.length - 1];
                               let transcript = result[0].transcript.trim();
                               console.log("Transcript raw:", transcript);

                               if (transcript.length > 0 && commentInput) {
                                   const stopKeywords = ['stop', 'stopp', 'aufnahme beenden', 'danke', 'fertig'];
                                   const lowerTranscript = transcript.toLowerCase();
                                   let stoppedIntentionally = false;
                                   for (const keyword of stopKeywords) {
                                       if (lowerTranscript.endsWith(keyword)) {
                                           console.log(`Stop keyword '${keyword}' detected.`);
                                           transcript = transcript.substring(0, transcript.length - keyword.length).trim();
                                           stoppedIntentionally = true;
                                           break;
                                       }
                                   }

                                   const needsSpace = commentInput.value.length > 0 && !commentInput.value.endsWith(' ');
                                   commentInput.value += (needsSpace ? ' ' : '') + transcript;
                                   commentInput.scrollTop = commentInput.scrollHeight; // Scroll to bottom
                                   enforceCommentLimit(); // Includes updateClearButtonVisibility

                                   if (stoppedIntentionally && recognition && isMicRecording) {
                                       console.log("Stopping recognition due to keyword.");
                                       try { recognition.stop(); } catch(e){ console.warn("Error stopping recognition after keyword:", e);}
                                   }

                               } else { console.log("Received empty transcript."); }
                           } else { console.log("No results received."); }
                           // Let onend handle the final state reset after transcription potentially finishes
                        };

                        recognition.onerror = (event) => {
                           console.error('Speech recognition error:', event.error, event.message);
                           let errorMessage = 'Spracherkennungsfehler.';
                           if (event.error !== 'aborted' && event.error !== 'no-speech') {
                               if(commentError) commentError.textContent = errorMessage;
                               playSound('error');
                           } else if (event.error === 'no-speech') {
                               if(commentError) commentError.textContent = 'Nichts gehört.';
                           } else if (event.error === 'aborted') {
                               console.log("Recognition aborted (likely intentional stop).");
                               if(commentError && commentError.textContent === 'Höre zu...') commentError.textContent = '';
                           }
                           // onend will fire after error, let it handle state reset
                           isMicRecording = false; isTranscribing = false; // Ensure state is reset here too just in case
                        };

                        recognition.onend = () => {
                            console.log("Speech recognition ended.");
                            const wasRecording = isMicRecording; // Store state before resetting
                            isMicRecording = false; isTranscribing = false; // Reset state first

                            if (recordButton) {
                                recordButton.classList.remove('is-recording', 'is-transcribing');
                                // Re-enable ONLY if NOT submitting AND a group is selected
                                recordButton.disabled = isSubmitting || !selectedGroup || !speechApiSupported;
                                recordButton.title = speechApiSupported ? (selectedGroup ? "Kommentar sprechen..." : "Gruppe auswählen zum Diktieren") : "Spracherkennung nicht unterstützt";
                                const defaultIcon = recordButton.querySelector('.mic-icon.default'); const recordingIcon = recordButton.querySelector('.mic-icon.recording');
                                if (defaultIcon) defaultIcon.style.display = 'inline'; if (recordingIcon) recordingIcon.style.display = 'none';
                             }
                             if (commentError && (commentError.textContent.startsWith('Höre zu...') || commentError.textContent.startsWith('Verarbeite...') || commentError.textContent.startsWith('Nichts gehört.'))) {
                                 commentError.textContent = '';
                             }

                            // Re-enable inputs ONLY IF NOT SUBMITTING AND a group is selected
                            if (!isSubmitting && selectedGroup) {
                                if (feedbackRatingButtons) feedbackRatingButtons.forEach(btn => btn.disabled = false);
                                // if (allGroupButtons) allGroupButtons.forEach(btn => btn.disabled = false); // Groups remain enabled
                                if (clearCommentButton) clearCommentButton.disabled = (commentInput.value.length === 0); // Enable only if text exists
                            } else if (!isSubmitting && !selectedGroup) {
                                // If no group is selected (e.g., user deselected during recording), ensure controls are disabled
                                disableControls();
                            }
                            // Always update visibility in case text was added
                            updateClearButtonVisibility();
                        };

                    } else {
                         console.warn("Web Speech API is not supported."); speechApiSupported = false;
                         if (recordButton) { recordButton.disabled = true; recordButton.title = "Spracherkennung nicht unterstützt"; }
                         if (commentInput) {
                             commentInput.placeholder = "Diktierfunktion nicht unterstützt";
                             // commentInput.disabled = true; // Let CSS handle non-interactivity via parent
                         }
                    }
                    // --- End Web Speech API Setup ---

                    // --- Functions Definitions ---

                    function updateClearButtonVisibility() {
                        if (!commentInput || !clearCommentButton) return;
                        try {
                            const commentText = commentInput.value.trim();
                            const canBeEnabled = selectedGroup && !isSubmitting && !isMicRecording && !isTranscribing;

                            if (commentText.length > 0) {
                                clearCommentButton.classList.remove('hidden');
                                clearCommentButton.disabled = !canBeEnabled;
                                clearCommentButton.textContent = CLEAR_BUTTON_TEXT_DELETE;
                            } else {
                                clearCommentButton.classList.add('hidden');
                                clearCommentButton.disabled = true; // Always disable if hidden
                                clearCommentButton.textContent = CLEAR_BUTTON_TEXT_DELETE;
                            }
                        } catch (e) {
                            console.error("Err update clear visibility:", e);
                            if(clearCommentButton) {
                                clearCommentButton.classList.add('hidden');
                                clearCommentButton.disabled = true;
                                clearCommentButton.textContent = CLEAR_BUTTON_TEXT_DELETE;
                            }
                        }
                    }

                    function enforceCommentLimit() {
                         if (!commentInput || !commentError) return;
                         const currentComment = commentInput.value;
                         const limitExceededMsg = `Max. ${maxCommentLength} Zeichen erlaubt`;
                         if (currentComment.length > maxCommentLength) {
                             console.warn(`Comment truncated to ${maxCommentLength} chars.`);
                             commentInput.value = currentComment.substring(0, maxCommentLength);
                             if (commentError.textContent !== limitExceededMsg && !commentError.textContent.includes('Was hat nicht geschmeckt? Bitte sprich einige Worte.')) {
                                commentError.textContent = limitExceededMsg;
                             }
                         } else {
                             if (commentError.textContent === limitExceededMsg) {
                                commentError.textContent = '';
                             }
                         }
                         updateClearButtonVisibility(); // Check button state after change
                    }

                    function playSound(soundKey) { /* ... (no changes needed) ... */
                        if (!sounds[soundKey]) {console.warn(`Sound ${soundKey} not found.`); return null;}
                        try {
                            if (lastPlayedRatingSound && soundKey.startsWith('rating-')) {
                                lastPlayedRatingSound.pause();
                                lastPlayedRatingSound.currentTime = 0;
                             }
                            sounds[soundKey].currentTime = 0;
                            const p = sounds[soundKey].play();
                            if(p) p.then(_ => {if (soundKey.startsWith('rating-')) lastPlayedRatingSound = sounds[soundKey];}).catch(e=>console.error(`Audio Err ${soundKey}:`, e));
                            return sounds[soundKey];
                        } catch(e){console.error(`Play Err ${soundKey}:`,e);}
                        return null;
                    }
                    function showScreen(screenToShow){ document.querySelectorAll('.screen').forEach(s=>s.classList.remove('active')); screenToShow.classList.add('active'); }
                    function formatTimestamp(date){ const p=(n)=>n.toString().padStart(2,'0'); return `${p(date.getDate())}.${p(date.getMonth()+1)}.${date.getFullYear()} ${p(date.getHours())}:${p(date.getMinutes())}:${p(date.getSeconds())}`; }

                    // --- CHANGE: Functions to enable/disable controls ---
                    function enableControls() {
                        console.log("Enabling controls");
                        if (feedbackScreen) feedbackScreen.classList.remove('controls-disabled');
                        if (feedbackRatingButtons) feedbackRatingButtons.forEach(btn => btn.disabled = false);
                        if (recordButton) {
                            recordButton.disabled = !speechApiSupported; // Enable only if API is supported
                            recordButton.title = speechApiSupported ? "Kommentar sprechen..." : "Spracherkennung nicht unterstützt";
                        }
                        // Clear button state depends on content, update it
                        updateClearButtonVisibility();
                    }

                    function disableControls() {
                        console.log("Disabling controls");
                        if (feedbackScreen) feedbackScreen.classList.add('controls-disabled');
                        if (feedbackRatingButtons) feedbackRatingButtons.forEach(btn => btn.disabled = true);
                        if (recordButton) {
                            recordButton.disabled = true;
                             recordButton.title = "Gruppe auswählen zum Diktieren";
                        }
                        if (clearCommentButton) clearCommentButton.disabled = true; // Force disable

                         // If mic was active when controls were disabled, abort it.
                        if ((isMicRecording || isTranscribing) && recognition) {
                            try {
                                console.log("Aborting recognition due to control disable.");
                                recognition.abort();
                             } catch (e) { console.warn("Error aborting recognition on disable:", e); }
                             // Ensure state is reset fully
                            isMicRecording = false; isTranscribing = false;
                            // Reset mic button appearance manually if abort() doesn't trigger onend quickly
                            if (recordButton) {
                                recordButton.classList.remove('is-recording', 'is-transcribing');
                                const defaultIcon = recordButton.querySelector('.mic-icon.default'); const recordingIcon = recordButton.querySelector('.mic-icon.recording');
                                if (defaultIcon) defaultIcon.style.display = 'inline'; if (recordingIcon) recordingIcon.style.display = 'none';
                            }
                        }
                    }
                    // --- End enable/disable functions ---

                    function deselectAllGroups(){
                        console.log("Deselecting all groups.");
                        selectedGroup = null;
                        if (feedbackScreen) feedbackScreen.classList.remove('group-selected');
                        if (allGroupButtons) allGroupButtons.forEach(btn => btn.classList.remove('selected'));
                        // --- CHANGE: Call disableControls ---
                        disableControls();
                        console.log(`Selected group after deselect: ${selectedGroup}`);
                    }

                    function resetApp() {
                        console.log("--- Resetting App ---");
                        isSubmitting = false; // Ensure submitting flag is reset first
                        selectedRating = null;

                        deselectAllGroups(); // This now also handles disabling controls

                        if (commentInput) {
                           commentInput.value = '';
                           // Placeholder is set in HTML, update just in case API status changed (unlikely)
                           commentInput.placeholder = speechApiSupported ? "Kommentar sprechen..." : "Diktierfunktion nicht unterstützt";
                        }
                        if (commentError) commentError.textContent = '';
                        if (loadingIndicator) loadingIndicator.style.display = 'none';

                        if (allGroupButtons) allGroupButtons.forEach(btn => btn.disabled = false); // Group buttons are always enabled

                        updateClearButtonVisibility(); // Reset button state/visibility (will be hidden and disabled)
                        lastPlayedRatingSound = null;
                        if (feedbackScreen && thankYouScreen) showScreen(feedbackScreen);
                        console.log("--- App Reset Complete ---");
                    }


                    async function submitFeedback() { /* ... (no changes needed in logic, but ensure re-enable respects selectedGroup) ... */
                        console.log("%c--- SUBMITTING FEEDBACK ---", "color: blue; font-weight: bold;");
                        const groupErrorMsg = 'Bitte zuerst eine Gruppe auswählen.';
                        const ratingErrorMsg = 'Bitte eine Bewertung auswählen.';
                        const micErrorMsg = 'Bitte warten bis die Spracheingabe fertig ist.';
                        const lengthErrorMsg = `Max. ${maxCommentLength} Zeichen erlaubt.`;
                        const requiredErrorMsg = `Was hat nicht geschmeckt? Bitte sprich einige Worte.`;

                        if (!selectedGroup) { console.warn("Submit stopped: Group missing."); if(commentError) commentError.textContent = groupErrorMsg; playSound('error'); return; }
                        if (!selectedRating) { console.warn("Submit stopped: Rating missing."); if(commentError) commentError.textContent = ratingErrorMsg; playSound('error'); return; }
                        if (isSubmitting) { console.warn("Submit stopped: Already submitting."); return; }
                        if (isMicRecording || isTranscribing) { console.warn("Submit stopped: Mic active."); if(commentError) commentError.textContent = micErrorMsg; playSound('error'); return; }

                        const currentComment = commentInput ? commentInput.value : '';
                        const trimmedComment = currentComment.trim();

                        if (currentComment.length > maxCommentLength) { console.warn("Submit stopped: Comment too long."); if(commentError) commentError.textContent = lengthErrorMsg; playSound('error'); return; }
                        if (selectedRating === "3" && trimmedComment.length < commentRequiredLength) { console.warn("Submit stopped: Comment required/too short."); if(commentError) commentError.textContent = requiredErrorMsg; playSound('error'); return; }

                        isSubmitting = true;
                        if(loadingIndicator) loadingIndicator.style.display = 'block';
                        if (commentError && [groupErrorMsg, ratingErrorMsg, micErrorMsg, lengthErrorMsg, requiredErrorMsg].includes(commentError.textContent)) {
                             commentError.textContent = '';
                        }

                        // Disable ALL interactive elements during submit
                        if(feedbackRatingButtons) feedbackRatingButtons.forEach(btn => btn.disabled = true);
                        if(allGroupButtons) allGroupButtons.forEach(btn => btn.disabled = true); // Also disable group selection during submit
                        if(recordButton) recordButton.disabled = true;
                        if(clearCommentButton) clearCommentButton.disabled = true;
                        // commentInput click prevention handled by parent opacity/pointer-events or disabling buttons

                        const timestamp = formatTimestamp(new Date());
                        const dataToSend = { timestamp: timestamp, gruppe: selectedGroup, bewertung: selectedRating, kommentar: currentComment };
                        console.log("Data to send:", dataToSend);

                        try {
                            await fetch(googleAppsScriptUrl, { method: 'POST', mode: 'no-cors', cache: 'no-cache', headers: { 'Content-Type': 'text/plain;charset=utf-8' }, body: JSON.stringify(dataToSend) });
                            console.log("Fetch completed (assumed success).");
                            if (lastPlayedRatingSound) { lastPlayedRatingSound.pause(); lastPlayedRatingSound.currentTime = 0; }
                            playSound('sent');
                            showScreen(thankYouScreen);
                            setTimeout(resetApp, thankYouDuration); // resetApp will handle initial disabled state

                        } catch (error) {
                            console.error("Submission Fetch Error:", error);
                            if(loadingIndicator) loadingIndicator.style.display = 'none';
                            if(commentError) commentError.textContent = 'Fehler beim Senden.';
                            playSound('error');
                            // Re-enable appropriate buttons on error
                            isSubmitting = false;
                            if(allGroupButtons) allGroupButtons.forEach(btn => btn.disabled = false); // Re-enable group buttons

                            // --- CHANGE: Re-enable controls *only if* a group is still selected ---
                            if (selectedGroup) {
                                enableControls(); // This handles rating buttons, mic button, clear button visibility
                            } else {
                                disableControls(); // Ensure controls stay disabled if group was somehow deselected
                            }
                        }
                    }


                    function toggleRecording() { /* ... (no changes needed) ... */
                        if (!recognition || !speechApiSupported || isSubmitting || isTranscribing || !selectedGroup) {
                            console.log("Toggle recording blocked: API unavailable, submitting, transcribing, or no group selected.");
                             if(!selectedGroup && commentError) commentError.textContent = 'Bitte zuerst Gruppe auswählen.';
                            return;
                        }

                        if (isMicRecording) {
                            console.log("Stopping recording via toggle.");
                            try {
                                recognition.stop();
                            } catch (e) {
                                console.error("Error stopping recognition:", e);
                                isMicRecording = false; // Force reset state
                                // Manually trigger parts of onend if needed
                            }
                        } else {
                            console.log("Starting recording via toggle.");
                            if(commentError && (commentError.textContent === 'Bitte warten bis die Spracheingabe fertig ist.' || commentError.textContent === 'Nichts gehört.' || commentError.textContent === 'Spracherkennungsfehler.' || commentError.textContent === 'Bitte zuerst Gruppe auswählen.')) {
                                commentError.textContent = '';
                            }
                            try {
                                recognition.start();
                            } catch (e) {
                                console.error("Error starting recognition:", e);
                                if(commentError) commentError.textContent = 'Fehler beim Start der Spracheingabe.';
                                playSound('error');
                                isMicRecording = false; // Reset state if start fails
                                // Ensure buttons get re-enabled if start fails immediately and group is selected
                                if (!isSubmitting && selectedGroup) {
                                     enableControls();
                                }
                            }
                        }
                    }


                    // --- EVENT LISTENER ATTACHMENT ---
                    console.log("Attaching event listeners...");
                    try {
                        // Group Buttons Listener
                        if (allGroupButtons) {
                            allGroupButtons.forEach((button) => {
                                const groupName = button.dataset.group; if (!groupName) return;
                                button.addEventListener('click', (event) => {
                                    if (isSubmitting) return; // Allow changing group while mic is active, but not submitting
                                    const clickedButton = event.currentTarget;
                                    const wasSelected = clickedButton.classList.contains('selected');
                                    const previouslySelectedGroup = selectedGroup;

                                    // If clicking the *same* selected button, deselect it.
                                    if (wasSelected) {
                                        deselectAllGroups(); // Disables controls
                                    } else {
                                        // Selecting a new group (or the first group)
                                        // First, deselect visually if another was selected
                                        if (selectedGroup) {
                                             allGroupButtons.forEach(btn => btn.classList.remove('selected'));
                                        }
                                        // Now select the new one
                                        selectedGroup = groupName;
                                        console.log(`Selected group: ${selectedGroup}`);
                                        clickedButton.classList.add('selected');
                                        if (feedbackScreen) feedbackScreen.classList.add('group-selected');

                                        // --- CHANGE: Enable controls ---
                                        enableControls();

                                        // Play sound only if it's a class group
                                        if (['1-4 Klasse', '5-8 Klasse', '9-12 Klasse'].includes(groupName)) playSound(groupName);
                                        if(commentError && commentError.textContent === 'Bitte zuerst eine Gruppe auswählen.') commentError.textContent = '';

                                        // If mic was running while group was switched, stop it gently.
                                        if ((isMicRecording || isTranscribing) && recognition && previouslySelectedGroup) {
                                            console.log("Stopping recognition due to group change.");
                                             try { recognition.abort(); } catch (e) { console.warn("Error aborting recognition on group change:", e); }
                                             // Reset mic state manually if needed
                                             isMicRecording = false; isTranscribing = false;
                                        }
                                    }
                                });
                            });
                            console.log("Attached Group Listeners.");
                        }

                        // Rating Buttons Listener
                        if (feedbackRatingButtons) {
                            feedbackRatingButtons.forEach((button) => {
                                const ratingValue = button.dataset.rating; if (!ratingValue) return;
                                button.addEventListener('click', (event) => {
                                    // --- CHANGE: Check button disabled status explicitly ---
                                    if (isSubmitting || isMicRecording || isTranscribing || event.currentTarget.disabled) return;
                                     if(commentError && commentError.textContent === 'Bitte eine Bewertung auswählen.') commentError.textContent = '';

                                    selectedRating = ratingValue; console.log('Selected rating:', selectedRating);
                                    const currentComment = commentInput ? commentInput.value.trim() : '';

                                    if (selectedRating === "3" && currentComment.length < commentRequiredLength) {
                                         if (commentError) commentError.textContent = `Was hat nicht geschmeckt? Bitte sprich einige Worte.`;
                                         if (lastPlayedRatingSound) { lastPlayedRatingSound.pause(); lastPlayedRatingSound.currentTime = 0; }
                                         lastPlayedRatingSound = playSound('rating-3-success');
                                         playSound('error');
                                         return; // Don't submit yet
                                    }

                                    let soundKey = `rating-${selectedRating}`;
                                    if (selectedRating === "3") soundKey = 'rating-3-success';
                                    if (lastPlayedRatingSound) { lastPlayedRatingSound.pause(); lastPlayedRatingSound.currentTime = 0; }
                                    lastPlayedRatingSound = playSound(soundKey);
                                    submitFeedback(); // Attempt submission
                                });
                            });
                            console.log("Attached Rating Listeners.");
                        }

                        // Microphone Button Listener
                        if (recordButton && speechApiSupported) {
                           recordButton.addEventListener('click', toggleRecording);
                           console.log("Attached Mic Button Listener.");
                        } // Disabled state handled by enable/disableControls

                        // Textarea Click Listener
                         if (commentInput && speechApiSupported) {
                           commentInput.addEventListener('click', (event) => {
                               // --- CHANGE: Prevent toggle if controls are disabled ---
                               if (feedbackScreen.classList.contains('controls-disabled')) {
                                   console.log("Textarea click ignored: controls disabled.");
                                   if (!selectedGroup && commentError) { // Show group error if reason is no group
                                        commentError.textContent = 'Bitte zuerst Gruppe auswählen.';
                                   }
                                   return;
                               }
                               toggleRecording();
                           });
                           console.log("Attached Textarea Click Listener.");
                         }

                        // Clear Comment Button Listener
                        if (clearCommentButton) {
                           clearCommentButton.addEventListener('click', (event) => {
                               // --- CHANGE: Check disabled status explicitly ---
                                if (event.currentTarget.disabled || isSubmitting || isMicRecording || isTranscribing) return;

                                console.log("Kommentar löschen clicked");
                                if (commentInput) commentInput.value = '';

                                if(commentError && (commentError.textContent.includes(maxCommentLength) || commentError.textContent.includes('Was hat nicht geschmeckt? Bitte sprich einige Worte.'))) {
                                    commentError.textContent = '';
                                }
                                updateClearButtonVisibility(); // Hide button after clearing
                           });
                           console.log("Attached Clear Comment Listener.");
                        }

                        // Comment Input Listener (programmatic changes)
                         if (commentInput) {
                            commentInput.addEventListener('input', () => {
                                enforceCommentLimit(); // Handles max length and clear button visibility
                                if (selectedRating === "3" && commentError?.textContent.includes("Was hat nicht geschmeckt? Bitte sprich einige Worte.")) {
                                    if (commentInput.value.trim().length >= commentRequiredLength) {
                                        if (!commentError.textContent.includes(maxCommentLength)) {
                                             commentError.textContent = '';
                                        }
                                    }
                                }
                             });
                            console.log("Attached 'input' listener to comment box (for programmatic changes).");
                         }

                    } catch (listenerError) {
                        console.error("Error attaching event listeners:", listenerError);
                    }
                    // --- End Listener Attachment ---

                    // --- Initial Setup ---
                    console.log("Running Initial Setup...");
                    resetApp(); // Calls deselectAllGroups which calls disableControls
                    console.log("--- App Initialized Successfully ---");

                } catch (initError) {
                    console.error("Error during DOMContentLoaded initialization:", initError);
                     document.body.innerHTML = '<p style="color: red; text-align: center; padding: 20px;">Ein Fehler ist beim Initialisieren der Anwendung aufgetreten. Bitte laden Sie die Seite neu.</p>';
                }
            }); // End DOMContentLoaded listener
        } catch (globalError) {
             console.error("Global script error:", globalError);
             document.body.innerHTML = '<p style="color: red; text-align: center; padding: 20px;">Ein unerwarteter Fehler ist aufgetreten. Bitte laden Sie die Seite neu.</p>';
        }
        console.log("--- script.js finished parsing (sync part) ---");
        // --- END OF updated script.js content ---
    </script>
</body>
</html>
